#!/bin/bash
logfile=/var/log/mhagent.log

# init
if [ ! -f $logfile ]; then touch $logfile; fi

# this command accepts two parameters:  filename, extension
# the return value is the filename without the extension, or just the filename if it
# didn't end with the specified extension
# this command is similar to the 'basename' command, which strips out the path
# and an optional extension, but does not strip out the path.
# examples:
#   basename      /path/to/filename.ext .ext   --> filename
#   path_basename /path/to/filename.ext .ext   --> /path/to/filename
#   basename      /path/to/filename.ext1 .ext2 --> filename.ext1
#   path_basename /path/to/filename.ext1 .ext2 --> /path/to/filename.ext1
path_basename() {
  local infiledir=`dirname $1`
  local infilebasename=`basename $1 $2`
  local outfile="$infiledir/$infilebasename"
  echo "$outfile"
}

md5() {
  local file="$1"
  md5sum "$file" | awk '{ print $1 }'
}


mh_log() {
  #local datestr=`date '+%Y-%m-%d %H:%M:%S'`
  # use RFC 822 format
  local datestr=`date -R`
  echo "[$datestr] $$ $@" >> $logfile
}

openssl_encrypted_file() {
  local filename="$1"
  encheader=`hd -n 8 $filename | head -n 1 | grep "Salted__"`
  if [ -n "$encheader" ]; then
    return 0
  fi
  return 1
}

mh_encrypt() {
  local infile="$1"
  local encfile="$infile.enc"
  if [ ! -f $infile ]; then
    echo "error: failed to encrypt $infile: file not found"
    return 1
  fi
  if openssl_encrypted_file $infile; then
    echo "error: failed to encrypt $infile: already encrypted";
    return 2;
  fi
  openssl enc -aes-128-ofb -in "$infile" -out "$encfile" -pass pass:password
  if openssl_encrypted_file $encfile; then
    mv $encfile $infile
    return 0
  fi
  echo "error: failed to encrypt $infile"
  return 3
}

mh_decrypt() {
  local infile="$1"
  local decfile="$infile.dec"
  if [ ! -f $infile ]; then
    echo "error: failed to decrypt $infile: file not found"
    return 1
  fi
  if ! openssl_encrypted_file $infile; then
    echo "error: failed to decrypt $infile: not encrypted";
    return 1
  fi
  if [ -n "$IMAGE_ID" ]; then
    mh_log "Found encrypted image: $IMAGE_ID"
  fi

  # XXX DEBUG for debugging only - copy the original image file to a tmp location for dev to look at it after
  cp $infile /tmp/image.enc

  # file is encrypted -- but we need the decryption key. mh_request_dek will
  # request it from the key mgmt svc and place it in the var MH_DEK
  # in order to request the dek we need to know the url from where to download
  # it, which must be provided as an argument --dek-url
  mh_request_dek $DEK_URL
  #openssl enc -d -aes-128-ofb -in "$infile" -out "$decfile" -pass pass:password
  openssl enc -d -aes-128-ofb -in "$infile" -out "$decfile" -pass env:MH_DEK
  if ! openssl_encrypted_file $decfile; then
    if [ -n "$IMAGE_ID" ]; then
      mh_log "Decrypted image: $IMAGE_ID"
      # XXX DEBUG for debugging only - 
      cp $decfile /tmp/image.dec
    fi
    mv $decfile $infile
    return 0
  fi
  echo "error: failed to decrypt $infile"
  return 2
  #local infiledir=`dirname $infile`
  #local infilebasename=`basename $infile .enc`
  #local outfile="$infiledir/$infilebasename"
  #mv $decfile $outfile
}

parse_args() {
  if ! options=$(getopt -n mhagent -l project-id:,instance-name:,base-image:,image-id:,target:,checksum:,dek-url: -- "$@"); then exit 1; fi
  eval set -- "$options"
  while [ $# -gt 0 ]
  do
    case $1 in
      --project-id) PROJECT_ID="$2"; shift;;
      --instance-name) INSTANCE_NAME="$2"; shift;;
      --base-image) BASE_IMAGE="$2"; shift;;
      --image-id) IMAGE_ID="$2"; shift;;
      --target) TARGET="$2"; shift;;
      --checksum) CHECKSUM="$2"; shift;;
      --dek-url) DEK_URL="$2"; shift;;
    esac
    shift
  done
}

mh_launch() {
  mh_log "mh_launch: $@"
  mh_log "Project Id: $PROJECT_ID"
  mh_log "Instance Name: $INSTANCE_NAME"
  mh_log "Base Image: $BASE_IMAGE"
  mh_log "Image Id: $IMAGE_ID"
  mh_log "Target: $TARGET"
  mh_log "Checksum: $CHECKSUM"
  mh_log "DEK URL: $DEK_URL"
  #if [ -n "$BASE_IMAGE" ]; then
  if [ -n "$TARGET" ]; then
    #waitcounter=0
    #while [ ! -f /var/lib/nova/instances/_base/$BASE_IMAGE ] && [ $waitcounter -lt 10 ]; do
    #  mh_log "File not found:  /var/lib/nova/instances/_base/$BASE_IMAGE"
    #  waitcounter=$((waitcounter+1))
    #  mh_log "Waiting to find it again; waitcounter=$waitcounter max 10"
    #  sleep 1
    #done
    #if [ -f /var/lib/nova/instances/_base/$BASE_IMAGE ]; then
    if [ -f $TARGET ]; then
      mh_log "Found base image: $TARGET"
      #md5sum /var/lib/nova/instances/_base/$BASE_IMAGE >> $logfile
      # We rely on mh_decrypt to detect if the file is encrypted or not
      # (it could already be decrypted if this isn't the first launch)
      #mh_decrypt /var/lib/nova/instances/_base/$BASE_IMAGE >> $logfile
      mh_decrypt $TARGET >> $logfile
      # Either way we check that now the image checksum should match
      # what was passed in via --checksum
      #local current_md5=$(md5 /var/lib/nova/instances/_base/$BASE_IMAGE)
      local current_md5=$(md5 $TARGET)
      mh_log "Checksum after decryption: $current_md5"
      if [ "$current_md5" != "$CHECKSUM" ]; then
        mh_log "Error: checksum is $current_md5 but expected $CHECKSUM"
      fi
    else
      #mh_log "File not found:  /var/lib/nova/instances/_base/$BASE_IMAGE"
      mh_log "File not found: $TARGET"
    fi
  else
    mh_log "Missing parameter --target"
  fi
  #if [ -d /var/lib/nova/instances/$INSTANCE_NAME ]; then
  #  INSTANCE_DIR=/var/lib/nova/instances/$INSTANCE_NAME 
  #  mh_log "Instance Path: $INSTANCE_DIR"
  #fi
  #if [ -f /var/lib/nova/instances/_base/$PROJECT_ID ]; then
  #  PROJECT_FILE=/var/lib/nova/instances/_base/$PROJECT_ID
  #  mh_log "Base Image:  $PROJECT_FILE"
  #fi
  #if [ -n "$PROJECT_FILE" ]; then
  #  if [ -f "$PROJECT_FILE" ]; then
  #    mh_log "mh_launch: Decrypting $PROJECT_FILE"
  #    mh_decrypt $PROJECT_FILE >> $logfile
  #  else
  #    mh_log "mh_launch: Cannot decrypt file: file not found"
  #  fi
  #else
  #  mh_log "mh_launch: Cannot decrypt file: no base image"
  #fi
}

mh_terminate() {
  mh_log "mh_terminate: $@"
}

mh_suspend() {
  mh_log "mh_suspend: $@"
}

mh_suspend_resume() {
  mh_log "mh_suspend_resume: $@"
}

mh_pause() {
  mh_log "mh_pause: $@"
}

mh_pause_resume() {
  mh_log "mh_pause_resume: $@"
}

mh_fix_aik() {
  local aikdir=/etc/intel/cloudsecurity/cert

  # first prepare the aik for posting. trust agent keeps the aik at /etc/intel/cloudsecurity/cert/aikcert.cer in PEM format.
  if [ ! -f $aikdir/aikcert.crt ]; then
    if [ ! -f $aikdir/aikcert.pem ]; then
      # trust agent aikcert.cer is in broken PEM format... it needs newlines every 76 characters to be correct
      cat $aikdir/aikcert.cer | sed 's/.\{76\}/&\n/g' > $aikdir/aikcert.pem
    fi
    if [ -f $aikdir/aikcert.pem ]; then
      openssl x509 -in $aikdir/aikcert.pem -inform pem -out $aikdir/aikcert.crt -outform der
    fi
  fi

  if [ ! -f $aikdir/aikpubkey.pem ]; then
    if [ -f $aikdir/aikcert.crt ]; then
      openssl x509 -in $aikdir/aikcert.crt -inform der -pubkey -noout > $aikdir/aikpubkey.pem
      openssl rsa -in $aikdir/aikpubkey.pem -inform pem -pubin -out $aikdir/aikpubkey -outform der -pubout
    fi
  fi
}

# example:
# mh_request_dek https://10.254.57.240:8443/v1/data-encryption-key/request/testkey2
mh_request_dek() {
  local url="$1"
  mh_fix_aik
  local aikdir=/etc/intel/cloudsecurity/cert
  if [ ! -f $aikdir/aikpubkey.pem ]; then
    mh_log "Error: Missing AIK Public Key";
    echo "Missing AIK Public Key";
    exit 1
  fi

  #wget --no-check-certificate --header "Content-Type: application/octet-stream" --post-file=$aikdir/aikcert.crt "$url"
  #curl --verbose --insecure -X POST -H "Content-Type: application/octet-stream" --data-binary @$aikdir/aikcert.crt "$url"

  mh_log "Requesting DEK from: $url"

  curl --insecure -X POST -H "Content-Type: text/plain" --data-binary @$aikdir/aikpubkey.pem "$url" > /var/lib/nova/mh.dek.base64

  # XXX DEBUG for debugging only:
  cp  /var/lib/nova/mh.dek.base64 /tmp/dek.base64

  #export MH_DEK_RAW=`cat /var/lib/nova/mh.dek`

  export MH_DEK_BASE64=`cat /var/lib/nova/mh.dek.base64`

  # if client uses the raw key as input to openssl:
  #base64 -d < /var/lib/nova/mh.dek.base64 > /var/lib/nova/mh.dek
  #export MH_DEK=`cat /var/lib/nova/mh.dek`
  
  # if client uses the base64 encoded key as input to openssl:
  export MH_DEK="$MH_DEK_BASE64"

  # XXX DEBUG for debugging only:
  echo $MH_DEK > /tmp/dek.out
  cp  /var/lib/nova/mh.dek /tmp/dek

  mh_log "Received DEK from: $url"
  #mh_log "Received DEK: $MH_DEK"
  rm /var/lib/nova/mh.dek
}

mh_log "$@"
parse_args $@

case "$1" in
  version)
    echo "mhagent-0.1"
    ;;
  launch)
    shift
    mh_launch $@
    ;;
  launch-check)
    shift
    PROJECT_FILE=/var/lib/nova/instances/_base/$PROJECT_ID
    mh_log "launch-check $PROJECT_FILE"
    if [ -f $PROJECT_FILE ]; then
      md5sum $PROJECT_FILE >> $logfile
    else
      echo "cannot find $PROJECT_FILE" >> $logfile
    fi
    ;;
  terminate)
    shift
    mh_terminate $@
    ;;
  pause)
    shift
    mh_pause $@
    ;;
  pause-resume)
    shift
    mh_pause_resume $@
    ;;
  suspend)
    shift
    mh_suspend $@
    ;;
  suspend-resume)
    shift
    mh_suspend_resume $@
    ;;
  encrypt)
    shift
    mh_encrypt $@
    ;;
  decrypt)
    shift
    mh_decrypt $@
    ;;
  request-dek)
    shift
    mh_request_dek $@
    ;;
  *)
    echo "usage: mhagent version|launch|terminate|pause|pause-resume|suspend|suspend-resume|encrypt|decrypt"
    exit 1
esac

exit $?


